#! /bin/sh -
#
# 0mp-explore - View files of the whole code base tree in a pager.
#
# ---
#
# Copyright (c) 2017 Mateusz Piotrowski <mpp302@gmail.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

program='0mp-explore'
version=0.13.5

bold='\033[1m'
nobold='\033[0m'

shortusage() {
    proglen="$(printf '%s' "$program" | sed 's/./ /g')"

    cat <<EOF
Usage: $program [-AcnN-] [-rw REGEX] [--help] [--] [SCOPE...]
EOF
}

usage() {
    cat <<EOF
Usage: $program [OPTION...] [SCOPE...]

Positional arguments:
    SCOPE
        Files and directories to be explored by the program. If not provided
        then the scope is set to '.' (the current directory).

Environmental variables:
    _0MP_EXPLORE_OPTS
        Options to be passed to the program when it starts. They are processed
        before the options passed via the command line.

Options:
    -A, --ascii
        Replace the default character separating file names on the left side
        bar. Implies the --names option.

    -c, --colors
        Add syntax coloring with pygmentize which has to be installed. This
        option might slow down the program significantly.

    -n, --names
        Print currently viewed file name on the left side bar, next to the line
        numbers.

    -N, --nonumbers
        Don't print line numbers and file names on the left side bar.

    -r, --regex REGEX
        Set the regex string used to match files to be read; for example
        providing '.*.c' as a regex results in printing only C source files.

    -w, --wildcards REGEX
        Just like --regex but with a leading and a tailing wildcard .*. For
        example, "-r '*vector*'" and "-w vector" are effectively the same.

    -, --stdin
        Read scope files and directories from the standard input.

    --
        End of options. Treat the rest of the command line arguments as files
        and directories for program's scope.

    -h, --help, --shorthelp
        Show help.

    --version
        Show version.

Examples:
    $program -r '.*.c$' /usr/src
        View only C source files in the /usr/src directory.

    $program .bashrc Downloads/*.h
        View the .bashrc file and header files inside the Downloads directory.

EOF
}

# Parameters:
# $1 - The command which reads every file. Its output is then piped
#      into `cat -n`.
# Environmental variables:
# - bold
# - nobold
# - leftbar
# - leftbarseparator
# - names
# - regex
# - scope
explore() {
    # Pass the variables into the script and in the second here-doc add the
    # literal part of the script (no substitutions in the current shell).
    script="$(cat << EOF
command="$1"
bold="$bold"
nobold="$nobold"
leftbar="$leftbar"
leftbarseparator="$leftbarseparator"

EOF
    )
    $(cat << 'EOF'
for file
do
    # Skip binary files.
    grep --binary-file=without-match . "$file" 2>/dev/null 1>&2 || continue
    printf -- '%b%s%b\n' "$bold" "$file" "$nobold"

    if [ "@$leftbar@" = @names@ ]
    then
        $command "$file" | awk -v fn="$file" -v lbs="$leftbarseparator" '{
            if (NR % (length(fn) + 1) == 0) {
                printf "%s%5d  %s\n", lbs, NR, $0
            } else {
                printf "%1s%5d  %s\n", \
                    substr(fn, NR % (length(fn) + 1), 1), NR, $0
            }
        }'
    elif [ "@$leftbar@" = @nothing@ ]
    then
        $command "$file"
    else
        $command "$file" | awk '{ printf "%6d  %s\n", NR, $0 }'
    fi
    echo
done
EOF
    )"

    find ${scope:-'.'} \( -type f -o -type l \) -name "${regex:-*}" \
        -exec sh -c "$script" sh {} + 2>/dev/null | \
        less --no-init --chop-long-lines --RAW-CONTROL-CHARS --ignore-case
}

# Environmental variables:
# - leftbar
# - leftbarseparator
parse_opt_ascii() {
    leftbarseparator='|'
    leftbar=names
}

# Environmental variables:
# - colors
parse_opt_colors() {
    colors=yes
    if ! command -v pygmentize 2>/dev/null 1>&2
    then
        printf '%s: pygmentize is not available\n' "$program"
        exit 1
    fi
}

parse_opt_shorthelp() {
    shortusage
    exit 0
}

parse_opt_help() {
    usage
    exit 0
}

# Environmental variables:
# - leftbar
parse_opt_names() {
    leftbar=names
}

# Environmental variables:
# - leftbar
parse_opt_nonumbers() {
    leftbar=nothing
}

# Parameters:
# "$1" - Regex to be applied.
# Environmental variables:
# - regex
parse_opt_regex() {
    regex="$1"
}

# Environmental variables:
# - version
parse_opt_version() {
    printf '%s\n' "$version"
    exit 0
}

# Parameters:
# "$1" - Part of the regex to be applied.
# Environmental variables:
# - regex
parse_opt_wildcards() {
    regex="*$1*"
}

# Environmental variables:
# - scope
parse_opt_stdin() {
    while IFS= read stdinscope || [ -n "$stdinscope" ]
    do
        scope="${scope:-""} $stdinscope"
    done
}

# Parameters:
# $@ - Arguments to be parsed.
# Environmental variables:
# - colors
# - leftbar
# - leftbarseparator
# - regex
# - scope
parse() {
    while [ $# -gt 0 ]
    do
        case $1 in
            --ascii|-A) parse_opt_ascii ;;
            --colors|-c) parse_opt_colors ;;
            --shorthelp|-h) parse_opt_shorthelp ;;
            --help) parse_opt_help ;;
            --names|-n) parse_opt_names ;;
            --nonumbers|-N) parse_opt_nonumbers ;;
            --regex|-r) parse_opt_regex "${2?missing regex}"; shift ;;
            --version) parse_opt_version ;;
            --wildcards|-w) parse_opt_wildcards "${2?missing regex}"; shift ;;
            --stdin|-) parse_opt_stdin ;;
            --)
                shift
                if [ $# -gt 0 ]
                then
                    scope="${scope:-""} $@"
                fi
                break
                ;;
            -*)
                # String of short options glued together, e.g., '-Acw'.
                opts="${1#-}"

                while [ @@ != "@$opts@" ]
                do
                    opt="${opts%%"${opts#?}"}"
                    case $opt in
                        A) parse_opt_ascii ;;
                        c) parse_opt_colors ;;
                        h) parse_opt_shorthelp ;;
                        n) parse_opt_names ;;
                        N) parse_opt_nonumbers ;;
                        r) shift; parse_opt_regex "${1?missing regex}" ;;
                        w) shift; parse_opt_wildcards "${1?missing regex}" ;;
                        -) parse_opt_stdin ;;
                        *) ;;
                    esac
                    opts="${opts#"$opt"}"
                done
                ;;
            *)
                scope="${scope:-""} $1"
                ;;
        esac
        shift
    done
}

colors=
leftbar=
leftbarseparator='â–ˆ'
regex=
scope=

parse $_0MP_EXPLORE_OPTS
parse "$@"

scope="${scope# }"

if [ "@$colors@" = @yes@ ]
then
    explore 'pygmentize -g --'
else
    explore 'cat --'
fi
