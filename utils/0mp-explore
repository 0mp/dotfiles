#! /bin/sh -
#
# 0mp-explore - View files of the whole code base tree in a pager.
#
# ---
#
# Copyright (c) 2017-2018 Mateusz Piotrowski <0mp@FreeBSD.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

program='0mp-explore'
version=1.1.0

bold='\033[1m'
nobold='\033[0m'

shortusage() {
    cat <<EOF
Usage: $program [-AcnN-] [-rw REGEX] [--help] [--] [SCOPE...]
EOF
}

usage() {
    cat <<EOF
Usage: $program [OPTION...] [SCOPE...]

Positional arguments:
    SCOPE
        Files and directories to be explored by the program. If not provided
        then the scope is set to '.' (the current directory).

Environmental variables:
    _0MP_EXPLORE_OPTS
        Options to be passed to the program when it starts. They are processed
        before the options passed via the command line.

Options:
    -A, --ascii
        Replace the default character separating file names on the left side
        bar. Implies the --names option.

    -c, --colors
        Add syntax coloring with pygmentize which has to be installed. This
        option might slow down the program significantly.

    -n, --names
        Print currently viewed file name on the left side bar, next to the line
        numbers.

    -N, --nonumbers
        Don't print line numbers and file names on the left side bar.

    -r, --regex REGEX
        Set the regex string used to match files to be read; for example
        providing '.*.c' as a regex results in printing only C source files.

    -w, --wildcards REGEX
        Just like --regex but with a leading and a tailing wildcard .*. For
        example, "-r '*vector*'" and "-w vector" are effectively the same.

    -, --stdin
        Read scope files and directories from the standard input.

    --
        End of options. Treat the rest of the command line arguments as files
        and directories for program's scope.

    -h, --help, --shorthelp
        Show help.

    --version
        Show version.

Examples:
    $program -r '.*.c$' /usr/src
        View only C source files in the /usr/src directory.

    $program .bashrc Downloads/*.h
        View the .bashrc file and header files inside the Downloads directory.

EOF
}

# Parameters:
# $1 - The command which reads every file. Its output is then piped
#      into `cat -n`.
# Environmental variables:
# - command
# - bold
# - nobold
# - leftbar
# - leftbarseparator
# - names
# - regex
# - scope
explore() {
    # Pass the variables into the script and in the second here-doc add the
    # literal part of the script (no substitutions in the current shell).
    script="$(cat << EOF
command="$command"
bold="$bold"
nobold="$nobold"
leftbar="$leftbar"
leftbarseparator="$leftbarseparator"

EOF
    )
    $(cat << 'EOF'
for file
do
    # Skip binary files.
    grep --binary-file=without-match . "$file" 2>/dev/null 1>&2 || continue
    printf -- '%b%s%b\n' "$bold" "$file" "$nobold"

    if [ "@$leftbar@" = @names@ ]
    then
        $command "$file" | awk -v fn="$file" -v lbs="$leftbarseparator" '{
            pos = (NR + 1) % (length(fn) + 1)
            if (pos == 0)
                printf "%1s%5d  %s\n", lbs, NR, $0
            else
                printf "%1s%5d  %s\n", substr(fn, pos, 1), NR, $0
        }'
    elif [ "@$leftbar@" = @nothing@ ]
    then
        $command "$file"
    else
        $command "$file" | awk '{ printf "%6d  %s\n", NR, $0 }'
    fi
    echo ""
done
EOF
    )"

    find "${@:-.}" \( -type f -o -type l \) -name "${regex:-*}" \
        -exec sh -c "$script" sh {} + 2>/dev/null | \
        less --no-init --chop-long-lines --RAW-CONTROL-CHARS --ignore-case
}

# Environmental variables:
# - leftbar
# - leftbarseparator
parse_opt_ascii() {
    leftbarseparator='|'
    leftbar=names
}

# Environmental variables:
# - command
parse_opt_colors() {
    command='pygmentize -g --'
    if ! command -v pygmentize 2>/dev/null 1>&2
    then
        printf '%s: pygmentize is not available\n' "$program"
        exit 1
    fi
}

parse_opt_shorthelp() {
    shortusage
    exit 0
}

parse_opt_help() {
    usage
    exit 0
}

# Environmental variables:
# - leftbar
parse_opt_names() {
    leftbar=names
}

# Environmental variables:
# - leftbar
parse_opt_nonumbers() {
    leftbar=nothing
}

# Parameters:
# "$1" - Regex to be applied.
# Environmental variables:
# - regex
parse_opt_regex() {
    regex="$1"
}

# Environmental variables:
# - version
parse_opt_version() {
    printf '%s\n' "$version"
    exit 0
}

# Parameters:
# "$1" - Part of the regex to be applied.
# Environmental variables:
# - regex
parse_opt_wildcards() {
    regex="*$1*"
}

# Avoid filenames starting with a dash in find paths.
# https://stackoverflow.com/a/4286196/4694621
# "$1" - Argument to dotslashify.
dotslashify() {
    if [ "@${1%"${1#?}"}@" = '@-@' ]
    then
        printf '%s' "./$1"
    else
        printf '%s' "$1"
    fi
}

command='cat --'
leftbar=
leftbarseparator='â–ˆ'
regex=
scope=

state=''
for arg in $_0MP_EXPLORE_OPTS "$@"
do
    if [ -z "$state" ]
    then
        set --
        state=0
    fi

    case $state in
        1)
            state=0
            ;;
        --regex)
            parse_opt_regex "$arg"
            state=0
            ;;
        --wildcards)
            parse_opt_wildcards "$arg"
            state=0
            ;;
        skip)
            set -- "$@" "$(dotslashify "$arg")"
            ;;
        0)
            case $arg in
                -A|--ascii) parse_opt_ascii ;;
                -c|--colors) parse_opt_colors ;;
                -h|--shorthelp) parse_opt_shorthelp ;;
                -n|--names) parse_opt_names ;;
                -N|--nonumbers) parse_opt_nonumbers ;;
                -r|--regex) state=--regex ;;
                -w|--wildcards) state=--wildcards ;;
                -|--stdin)
                    while read stdin
                    do
                        set -- "$@" "$(dotslashify "$stdin")"
                    done
                    ;;
                --help) parse_opt_help ;;
                --version) parse_opt_version ;;
                --) state=skip ;;
                -*)
                    # String of short options glued together, e.g., '-Acw'.
                    opts="${arg#-}"

                    while [ @@ != "@$opts@" ]
                    do
                        opt="${opts%%"${opts#?}"}"
                        case $opt in
                            A) parse_opt_ascii ;;
                            c) parse_opt_colors ;;
                            h) parse_opt_shorthelp ;;
                            n) parse_opt_names ;;
                            N) parse_opt_nonumbers ;;
                            # --regex and --wildcards are mutually exclusive so
                            # we only remember the last state.
                            r) state=--regex ;;
                            w) state=--wildcards ;;
                            -)
                                while read stdin
                                do
                                    set -- "$@" "$(dotslashify "$stdin")"
                                done
                                ;;
                            *) ;;
                        esac
                        opts="${opts#"$opt"}"
                    done
                    ;;
                *)
                    set -- "$@" "$(dotslashify "$arg")"
                    ;;
            esac
            ;;
        *)
            echo 'invalid state reached during parsing of command line arguments' >&2
            ;;
    esac
done

# Make sure that we got all the arguments we need.
case $state in
    --regex|--wildcards)
        echo 'missing regex' >&2
        exit 1
        ;;
    *) ;;
esac

# Append files from SCOPE to find paths.
for scope in $SCOPE
do
    set -- "$@" "$(dotslashify "$scope")"
done

explore "$@"
