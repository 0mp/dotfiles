#! /bin/sh -
#
# 0mp-explore - View files of the whole code base tree in a pager.
#

program='0mp-explore'
version=0.5.14

bold='\033[1m'
nobold='\033[0m'

usage() {
    cat <<EOF
Usage: $program [OPTION...] [SCOPE...]

Positional arguments:
    SCOPE
        Files and directories to be explored by the program. If not provided
        then the scope is set to '.' (the current directory).

Options:
    -c, --colors
        Add syntax coloring with pygmentize which has to be installed. This
        option might slow down the program significantly.

    -r, --regex REGEX
        Regex string used to match files to be read; for example providing
        '.*.c' as a regex results in printing only C source files.

    -n, --names
        Print currently viewed file name on the left side bar, next to the line
        numbers.

    --
        End of options. Treat the rest of the command line arguments as files
        and directories for program's scope.

    -h, --help
        Show help.

    --version
        Show version.

Examples:
    $program -r '.*.c$' /usr/src
        View only C source files in the /usr/src directory.

    $program .bashrc Downloads/*.h
        View the .bashrc file and header files inside the Downloads directory.

EOF
}

# Parameters
# $1 - The command which reads every file. Its output is then piped
#      into `cat -n`.
# Environmental variables:
# - regex
# - scope
# - names
explore() {
    command="$1"

    find ${scope:-'.'} -type f -name "${regex:-*}" -exec sh -c "
        for file do
            # Skip binary files.
            grep --binary-file=without-match . \"\$file\" 2>/dev/null 1>&2 || \
                continue
            printf -- '%b%s%b\n' \"$bold\" \"\$file\" \"$nobold\"

            if [ x\"$names\" = xyes ]
            then
                $command \"\$file\" | \
                awk -v fn=\"\$file\" '{
                    if (NR % (length(fn) + 1) == 0) {
                        printf \"â–ˆ%5d  %s\n\", NR, \$0
                    }
                    else {
                        printf \"%1s%5d  %s\n\", substr(fn,
                            NR % (length(fn) + 1), 1), NR, \$0
                    }
                }'
            else
                $command \"\$file\" | \
                awk '{ printf \"%6d  %s\n\", NR, \$0 }'
            fi
            echo
        done
    " sh {} + | less --no-init --chop-long-lines --RAW-CONTROL-CHARS \
        --ignore-case
}

scope=
regex=
colors=
names=

while test $# -gt 0
do
    case $1 in
        --colors|-c)
            shift
            colors=yes
            if ! command -v pygmentize 1>&2 2>/dev/null
            then
                printf '%s: pygmentize is not available\n' "$program"
                exit 1
            fi
            ;;

        --help|-h)
            shift
            usage
            exit 0
            ;;

        --names|-n)
            names=yes
            shift
            ;;

        --regex|-r)
            shift
            regex="$1"
            shift
            ;;

        --version)
            shift
            printf '%s\n' "$version"
            exit 0
            ;;

        --)
            shift
            if [ $# -gt 0 ]
            then
                scope="${scope:-""} $@"
            fi
            break
            ;;

        *)
            scope="${scope:-""} $1"
            shift
            ;;
    esac
done

scope="${scope# }"

if test "x$colors" = "xyes"
then
    explore 'pygmentize -g --'
else
    explore 'cat --'
fi
