" Section: Vundle {{{
set nocompatible              " be iMproved, required
filetype off                  " required

" Set the runtime path to include Vundle and initialize.
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
" Alternatively, pass a path where Vundle should install plugins.
"call vundle#begin('~/some/path/here')

" Let Vundle manage Vundle, required.
Plugin 'VundleVim/Vundle.vim'

" Plugin 'ervandew/supertab'
Plugin 'scrooloose/nerdcommenter'
Plugin 'tpope/vim-repeat'
Plugin 'dahu/vim-fanfingtastic'
Plugin 'CycleColor' " Cycles through available colorschemes.
Plugin 'embear/vim-localvimrc' " Use .lvimrc for local configuration.

" All of your Plugins must be added before the following line
call vundle#end()            " required
filetype plugin indent on    " required
" Put your non-Plugin stuff after this line

filetype on           " Enable filetype detection
filetype plugin on    " Enable filetype-specific plugins
" }}}
" Section: Plugins configuration {{{
let NERDSpaceDelims=1

" Store and restore decisions only if the answer was given in upper case
" (Y/N/A).
let g:localvimrc_persistent = 1
let g:localvimrc_sandbox = 0

" Netrw
let g:netrw_banner=0 " Disable a banner.
" let g:netrw_liststyle=3 " Print as a tree.
let g:netrw_altv=1 " Open files to the right.

" }}}
" Section: Mappings {{{
" Leader needs some space.
let mapleader = " "

" Turn off highlighting.
nnoremap <leader>n :nohl<CR>

" Sudo saving.
cmap w!! w !sudo tee % >/dev/null

" Toggle paste mode.
nnoremap <leader>p<leader>p :set paste!<CR>p:set paste!<CR>

" Save.
" nnoremap <leader>w<leader> :w <CR>
nnoremap <leader>ww :set wrap! <CR>

" Disable the Ex mode.
map Q <Nop>

" Move cursor by display lines when wrapping
nnoremap <expr> j v:count ? 'j' : 'gj'
nnoremap <expr> k v:count ? 'k' : 'gk'
vnoremap <expr> j v:count ? 'j' : 'gj'
vnoremap <expr> k v:count ? 'k' : 'gk'

" Fight the <esc> <shift>-o delay.
set timeout timeoutlen=1000 ttimeoutlen=100

" Leader d sends targeted text into a black hole.
" Ref.: https://stackoverflow.com/a/11993928/4694621
nnoremap <leader>d "_d
vnoremap <leader>d "_d

" }}}
" Section: Miscellenous {{{
" Show the command you type in.
set showcmd
" Mouse scrolling.
set mouse=a

" One clipboard is enough for me.
set clipboard=unnamedplus
if substitute(system('uname'), "\n", "", "") == "Darwin"
    set clipboard=unnamed
endif

" Make backspace work like in most other apps.
set backspace=2

" Persistant undo history.
set undofile

" Ensure that .vimundo exists.
function! EnsureDirExists(dir)
  if !isdirectory(a:dir)
    if exists("*mkdir")
      call mkdir(a:dir,'p')
      echo "The " . a:dir .
                  \ " directory for persistant undo history has been created."
    else
      echo "Please create the " . a:dir .
                  \ " directory for persistant undo history manually."
    endif
  endif
endfunction

call EnsureDirExists($HOME . '/.vimundo')
set undodir=~/.vimundo/

" Show all the whitespace characters. Toggle with :set list!
"set listchars=eol:$,tab:>.,trail:~,extends:>,precedes:<
set listchars=eol:$,tab:>―,trail:~,extends:>,precedes:<


" Show and highlight search matches during typing.
set incsearch
set hlsearch

" Ignore case if search pattern is all lowercase, case-sensitive otherwise.
set smartcase
set ignorecase

" Works better for completions -> does not mix cases although ignorecase is
" set.
set infercase

" Look for the tags up in the directory tree.
set tags=./tags;/

" Disable full autocomplete in the last line mode.
set wildmode=list:longest,full

" Improve the autocompletion menu.
set completeopt=longest,menuone

" Ensure private editing.
" Setup: ln -s `which vim` /symlink/name/preferably/in/your/$PATH
" Usage: Just run `vimp`.
if v:progname == "vimp"
    echo "Private mode is on!"
    colorscheme slate
    set history=0
    set nobackup
    set nomodeline
    set noshelltemp
    set noswapfile
    set noundofile
    set nowritebackup
    set secure
    set viminfo=""
endif

" Fuzzy file opener.
" Usage: :find *.cpp
set path+=**
set wildmenu
" }}}
" Section: Files & buffers {{{
set history=500
set undolevels=500

set encoding=utf-8

" Does some magic with buffers.
set hidden

" You're right Adam, no one needs it!
set nobackup
set noswapfile

" Cycle through buffers.
nnoremap £ :bNext<CR>

" Support markdown syntax higlight for .md files.
au BufNewFile,BufFilePre,BufRead *.md set filetype=markdown

" Help Vim detect CUDA source files.
au BufNewFile,BufFilePre,BufRead *.cu set filetype=cuda
au BufNewFile,BufFilePre,BufRead *.cuh set filetype=cuda

" Python
au! FileType python setl nosmartindent

" YAML
autocmd FileType yaml setlocal ts=2 sts=2 sw=2 expandtab
" }}}
" Section: Automagic {{{
" Jump to where I left off last time.
if has("autocmd")
    au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
          \| exe "normal! g'\"" | endif
endif

" Remove trailing whitespace on file save.
function! <SID>StripTrailingWhitespaces()
    let _s=@/
    let l = line(".")
    let c = col(".")
    %s/\s\+$//e
    let @/=_s
    call cursor(l, c)
endfun
autocmd BufWritePre * :call <SID>StripTrailingWhitespaces()

" Autorefresh files.
set autoread

" Hide the preview window when using Vim's native autocompletion.
" http://stackoverflow.com/a/26022965/4694621
autocmd CompleteDone * pclose

" Lines in a commit message should not exceed 72 characters.
autocmd FileType gitcommit set tw=72

" }}}
" Section: Visuals {{{
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set relativenumber
set number

" Show cursor positions in the status bar.
set ruler

" Always show the tabline.
set showtabline=2

" Highlight the current line.
set cursorline

" Highlight the 81th column.
let &colorcolumn=0
nnoremap <leader>h :call ColorColumnToggle()<CR>
function! ColorColumnToggle()
    if &colorcolumn
        setlocal colorcolumn=0
    else
        setlocal colorcolumn=81
    endif
endfunction

" Don't let tmux mess the background colour.
" XXX: It might break some shortcuts though.
" Source: http://stackoverflow.com/q/6427650/4694621
if !has("gui_running")
    set term=screen-256color
    " set term=xterm
endif

" Indent wrapped lines and don't break in the middle of a word.
" XXX: Might break in older version.
" https://bluz71.github.io/2017/05/15/vim-tips-tricks.html
set lbr
set breakindent
set showbreak=\\_

syntax enable
colorscheme robpike
" }}}
" Section: Style {{{
set shiftwidth=4
set tabstop=4
set expandtab
set softtabstop=4

" Toggle between tabs and spaces.
function! TabToggle()
    if &expandtab
        set shiftwidth=8
        set tabstop=8
        set softtabstop=8
        set noexpandtab
        echo 'Using tabs for indentation from now on.'
    else
        set shiftwidth=4
        set tabstop=4
        set softtabstop=4
        set expandtab
        echo 'Using spaces for indentation from now on.'
    endif
endfunction
nnoremap <leader>t :call TabToggle()<CR>

set autoindent
set smartindent

" Round up indentation.
set shiftround
" }}}
" Section: FreeBSD {{{
" Copyright (c) 2007-2008 Sean C. Farley <scf@FreeBSD.org>
" Copyright (c) 2017 Mateusz Piotrowski <0mp@FreeBSD.org>
" All rights reserved.
"
" Redistribution and use in source and binary forms, with or without
" modification, are permitted provided that the following conditions
" are met:
" 1. Redistributions of source code must retain the above copyright
"    notice, this list of conditions and the following disclaimer,
"    without modification, immediately at the beginning of the file.
" 2. Redistributions in binary form must reproduce the above copyright
"    notice, this list of conditions and the following disclaimer in the
"    documentation and/or other materials provided with the distribution.
"
" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"
" $FreeBSD: src/tools/tools/editing/freebsd.vim,v 1.2 2008/07/30 03:34:23 scf Exp $

" This is a plugin for Vim (tested with Vim v7.1) to follow the FreeBSD style(9)
" indentation.  It registers a macro (see below) for changing a buffer's
" indentation rules but does not change the indentation of existing code.

" Load only once.
if ! exists('loaded_FreeBSD')
    let loaded_FreeBSD = 1

    " FreeBSD mapping to switch current buffer to style(9).
    nmap <silent> <Leader>sf :call FreeBSD_Style()<CR>

    " Ignore indents caused by parentheses in FreeBSD style.
    function! IgnoreParenIndent()
        let indent = cindent(v:lnum)

        if indent > 4000
            if cindent(v:lnum - 1) > 4000
                return indent(v:lnum - 1)
            else
                return indent(v:lnum - 1) + 4
            endif
        else
            return (indent)
        endif
    endfun

    " Follow the FreeBSD style(9).
    function! FreeBSD_Style()
        echo 'Using FreeBSD style from now on.'
        setlocal cindent
        setlocal cinoptions=(4200,u4200,+0.5s,*500,:0,t0,U4200,l1
        setlocal indentexpr=IgnoreParenIndent()
        setlocal indentkeys=0{,0},0),:,0#,!^F,o,O,e
        setlocal noexpandtab
        setlocal shiftwidth=8
        setlocal tabstop=8
        setlocal textwidth=80
    endfun
endif
" }}}
" Section: Homebrewed hacks {{{
" Look for help everywhere you can.
" FIXME
" nnoremap <silent> K :silent ! sh -c
"             \ '
"             \ (set -o pipefail; help <cword> 2>/dev/null <CR>\| less --no-init
"             \                                        --raw-control-chars
"             \                                        --quit-at-eof) \|\|
"             \ man <cword>
"             \ '
"             \ redraw! <CR>

" Sign highlight lines.
" TODO: Set signcolumn back to auto when you remove all the higlight signs.
if v:version >= 800
    set signcolumn=auto
    let s:sign_highlight_counter = 0
endif

hi GreenSignHighlightRow ctermbg=49 guibg='#00ffaf'
hi YellowSignHighlightRow ctermbg=226 guibg='#ffff00'
hi PinkSignHighlightRow ctermbg=177 guibg='#df87ff'

sign define GreenSignHighlightRow linehl=GreenSignHighlightRow
sign define YellowSignHighlightRow linehl=YellowSignHighlightRow
sign define PinkSignHighlightRow linehl=PinkSignHighlightRow

let g:last_used_highlight_color = 'GreenSignHighlightRow'
let s:sign_highlight_serial = 1

function PlaceSignHighlight(sign_highlight_group)
    " Redefine highlights as they could have been overwritten by changing
    " colorscheme.
    hi GreenSignHighlightRow ctermbg=49 guibg='#00ffaf'
    hi YellowSignHighlightRow ctermbg=226 guibg='#ffff00'
    hi PinkSignHighlightRow ctermbg=177 guibg='#df87ff'

    if v:version >= 800
        set signcolumn=no
    endif
    let l:linenum  = line(".")
    let s:sign_highlight_serial = s:sign_highlight_serial + 1
    exe ":sign place " . s:sign_highlight_serial .
                \ " line=" . l:linenum .
                \ " name=" . a:sign_highlight_group . " buffer=" . bufnr('%')
    if v:version >= 800
        let s:sign_highlight_counter = s:sign_highlight_counter + 1
    endif
    let g:last_used_highlight_color = a:sign_highlight_group
endfunction

function UnplaceSignHighlight()
    let l:linenum   = line(".")
    redir! > /tmp/sign-highlight.txt
    silent :exe ":sign place buffer=" . bufnr('%')
    redir END
    let l:id = system("cat /tmp/sign-highlight.txt | " .
                \ "grep line=" . l:linenum . " | head -1 ")
    let l:id = system("cut -d= -f3 | cut -d' ' -f1 | tr -d '\n'", l:id)

    if l:id
        exe ":sign unplace " . l:id . " buffer=" . bufnr('%')
        if v:version >= 800
            let s:sign_highlight_counter = s:sign_highlight_counter - 1
            if s:sign_highlight_counter == '0'
                set signcolumn=auto
            endif
        endif
    endif
endfunction

map <leader>ghh :call PlaceSignHighlight(g:last_used_highlight_color)<CR>
map <leader>gh1 :call PlaceSignHighlight('GreenSignHighlightRow')<CR>
map <leader>gh2 :call PlaceSignHighlight('YellowSignHighlightRow')<CR>
map <leader>gh3 :call PlaceSignHighlight('PinkSignHighlightRow')<CR>
map <leader>ghc :call UnplaceSignHighlight()<CR>

" function HighlightCursorLine()
"     let l:linenum   = line(".")
"     redir! > /tmp/sign-highlight.txt
"     silent :exe ":sign place buffer=" . bufnr('%')
"     redir END
"     let l:id = system("cat /tmp/sign-highlight.txt | " .
"                 \ "grep line=" . l:linenum . " | head -1 ")
"     let l:id = system("cut -d= -f3 | cut -d' ' -f1 | tr -d '\n'", l:id)

"     if l:id
"         hi CursorLine ctermfg=162 guifg='#df0087'
"     else
"         hi CursorLine ctermfg=NONE guifg=NONE
"     endif
" endfunction

" autocmd CursorMoved * call HighlightCursorLine()
" }}}

" Unfold the section under the cursor in .vimrc.
au BufWinEnter .vimrc normal! zv
" vim:foldmethod=marker:foldlevel=0:
